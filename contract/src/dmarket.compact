pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

/**** Notes:
- Contract Address Support: Seller, buyer, and carrier roles do not currently support contract addresses.
- Transaction History Storage: While transaction history is being stored, future versions may implement external storage solutions.
- Star Rating System: Ratings are calculated based on stars awarded in each transaction.
Each star corresponds to 50 rating points. For example, 150 rating points equals 3 stars.
    Rating Scale:
        [1, 50): 1 star
        [50, 100): 2 stars
        [100, 150): 3 stars
        [150, 200): 4 stars
        â‰¥ 200: 5 stars
- Dispute Initiation: Only buyers have the ability to open disputes at present, but future updates will allow carriers to do the same.
- Dispute Resolution: The seller currently acts as the arbitrator for disputes initiated by the buyer. In future versions, an option for selecting an external arbitrator service will be available.

TODO:
- Anonymization: Implement anonymization for sellers, buyers, and carriers using OpenZeppelin tools.
- Testing: Develop tests for circuit functionality.
- Deposits Management: Introduce a system for managing deposits.

****/

// Information kept for registered carriers
export struct Carrier {
  // Unique ID of the carrier
  id: Bytes<32>,
  // Wallet of the carrier where fees payment shall be sent.
  wallet: ZswapCoinPublicKey,
  // Average calculated based on the rating received in each transaction.
  rating: Uint<8>,
  // Number of completed transactions.
  txCompleted: Uint<128>,
  // Optional metadata, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>
}

// Information kept for registered sellers
export struct Seller {
  // Unique ID of the carrier
  id: Bytes<32>,
  // Wallet of the seller where payments shall be sent.
  wallet: ZswapCoinPublicKey,
  // Average calculated based on the rating received in each transaction.
  rating: Uint<8>,
  // Number of completed transactions.
  txCompleted: Uint<128>,
  // Optional metadata, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>
}

// Maps carriers IDs to their registered information.
// Updated only when a transaction is being completed.
export ledger carriers: Map<Bytes<32>, Carrier>;

// Maps sellers IDs to their registered information.
// Updated only when a transaction is being completed.
export ledger sellers: Map<Bytes<32>, Seller>;

// A list of active escrows. Maps the transaction IDs
// to the deposits made in relation to it.
export ledger escrowDeposits: Map<Bytes<32>, [Uint<128>, Uint<128>]>;

// Information of a buyer
export struct Buyer {
  id: Bytes<32>,
  meta: Opaque<'string'>
}

export ledger buyers: Map<Bytes<32>, Buyer>;

// Type to track the state of each published offer
export enum TxState {
  // New offer created and published.
  New,
  // A buyer selected the offer and made the deposit.
  Bought,
  // The carrier accepted and made the deposit.
  PickedUp,
  // The seller confirmed the item was picked up by the carrier for deivery. The seller
  // may request a signature to the carrier, generated by the dApp with
  // the carrier ID, to verify he/she is the effectivelly the carrier selected by the buyer.
  InTransit,
  // The carrier declares to have delivered the good/item. The carrier may request
  // a signature to the buyer, generated by the dApp with buyer ID, to confirm he/she is effectively the buyer.
  Delivered,
  // The buyer has opened a dispute which will need to be solved by the seller.
  Dispute,
  // Either the buyer confirmed the good/item was delivered and happy with it, or
  // a dispute was opened and already resolved by the seller.
  Completed
}

// Published item
export struct Item {
  // Id of the item.
  id: Bytes<32>,
  // ID of the seller.
  seller: Bytes<32>,
  // Price of the offered item.
  price: Uint<128>,
  // Optional metadata for the item, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>
}

// Maps the offer IDs to the carriers offered to deliver the item and their bidding fee price.
export ledger carrierBids: Map<Bytes<32>, Map<Bytes<32>, Uint<128>>>;

// Information defined when an offer is bought, including selected carrier and agreed fee
export struct BuyingDetails {
  buyerId: Bytes<32>,
  selectedCarrierId: Bytes<32>,
  carrierFee: Uint<128>
}

// Published offer
export struct Offer {
  // ID of the offer
  id: Bytes<32>,
  // The item/good being offered
  item: Item,
  // Current state of the offer
  state: TxState,
  // A tuple containing the buyer ID, the selected carrier ID, and the fee price.
  bought: Maybe<BuyingDetails>,
  // Estimated time of arrival (timestamp) of the item
  // Only the chosen carrier can set/update this value.
  deliveryEta: Uint<128>,
  // Rating given to the seller
  sellerRating: Uint<8>,
  // Rating given to the carrier
  carrierRating: Uint<8>,
  // Rating given to the buyer
  buyerRating: Uint<8>,
}

// Maps offers IDs to their info including state.
export ledger offers: Map<Bytes<32>, Offer>;

constructor() {
}

//
// TxState: () => New
export circuit offerItem(item: Item): Offer {
  const disclosedOfferId = disclose(genOfferId(item));
  assert(!offers.member(disclosedOfferId), "Offer aleady exists");

  const offer = Offer { ...default<Offer>, id: disclosedOfferId, item: item, state: TxState.New };
  offers.insert(disclosedOfferId, disclose(offer));
  return offer;
}

//
// TxState: New => New
export circuit setCarrierBid(offerId: Bytes<32>, fee: Uint<128>): [] {
  checkOfferState(offerId, TxState.New);

  const disclosedOfferId = disclose(offerId);
  if (!carrierBids.member(disclosedOfferId)) {
    carrierBids.insert(disclosedOfferId, default<Map<Bytes<32>, Uint<128>>>);
  }

  const disclosedCarrierId = disclose(genCarrierId(ownPublicKey()));
  carrierBids.lookup(disclosedOfferId).insert(disclosedCarrierId, disclose(fee));
  return [];
}

//
// TxState: New => Bought
export circuit buyItem(offerId: Bytes<32>): [] {
  const disclosedOfferId = disclose(offerId);
  const disclosedCarrierId = disclose(genCarrierId(ownPublicKey()));

  const offer = checkOfferState(offerId, TxState.New);

  assert(carrierBids.member(disclosedOfferId), "No carriers found for the offer");
  assert(carrierBids.lookup(disclosedOfferId).member(disclosedCarrierId), "Carrier not found among bidders");
  const fee = carrierBids.lookup(disclosedOfferId).lookup(disclosedCarrierId);

  // TODO: handle deposit according to price and carrier fee

  const buyerId = genBuyerId(ownPublicKey());
  const bought = some<BuyingDetails>(
                   BuyingDetails { buyerId: buyerId,
                                   selectedCarrierId: disclosedCarrierId,
                                   carrierFee: fee });
  const updatedOffer = Offer { ...offer, bought: bought, state: TxState.Bought };
  offers.insert(disclosedOfferId, updatedOffer);
  return [];
}

//
// TxState: Bought => PickedUp
export circuit itemPickedUp(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, TxState.Bought);
  assert(isCallerTheCarrier(offer), "Only the selected carrier can pick this item up for delivery");

  // TODO: handle deposit according to price

  setOfferState(offer, TxState.PickedUp);
  return [];
}

//
// TxState: PickedUp => InTransit
export circuit confirmItemInTransit(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, TxState.PickedUp);
  assert(isCallerTheSeller(offer), "Only the seller can confirm item has been picked up for delivery");

  setOfferState(offer, TxState.InTransit);
  return [];
}

//
// TxState: InTransit => Delivered
export circuit delivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, TxState.InTransit);
  assert(isCallerTheCarrier(offer), "Only the carrier can set the item as delivered");

  setOfferState(offer, TxState.Delivered);
  return [];
}

//
// TxState: Delivered => Completed
export circuit confirmDelivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, TxState.Delivered);
  assert(isCallerTheBuyer(offer), "Only the buyer can confirm the item has been delivered");

  // TODO: release deposits to each party

  setOfferState(offer, TxState.Completed);
  return [];
}

//
// TxState: Delivered => Dispute
// TODO: allow to dispute when it was not delivered but intransit
export circuit disputeItem(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, TxState.Delivered);
  assert(isCallerTheBuyer(offer), "Only the buyer can open a dispute on the item");

  setOfferState(offer, TxState.Dispute);
  return [];
}

//
// TxState: Dispute => Completed
export circuit resolveDispute(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, TxState.Dispute);
  assert(isCallerTheSeller(offer), "Only the seller can resolve a dispute");

  // TODO: relese deposits and apply confiscations accordingly

  setOfferState(offer, TxState.Completed);
  return [];
}

//
// TxState: Completed => Completed
export circuit rateSeller(offerId: Bytes<32>, rating: Uint<8>): [] {
  const offer = checkOfferState(offerId, TxState.Completed);
  assert(isCallerTheBuyer(offer), "Only the buyer of the offer can rate the seller");

  const updatedOffer = Offer { ...offer, sellerRating: disclose(rating) };
  offers.insert(disclose(offer.id), updatedOffer);
  return [];
}

//
// TxState: Completed => Completed
export circuit rateCarrier(offerId: Bytes<32>, rating: Uint<8>): [] {
  const offer = checkOfferState(offerId, TxState.Completed);
  assert(isCallerTheBuyer(offer), "Only the buyer of the offer can rate the carrier");

  const updatedOffer = Offer { ...offer, carrierRating: disclose(rating) };
  offers.insert(disclose(offer.id), updatedOffer);
  return [];
}

//
// TxState: Completed => Completed
export circuit rateBuyer(offerId: Bytes<32>, rating: Uint<8>): [] {
  const offer = checkOfferState(offerId, TxState.Completed);
  const txCaller = ownPublicKey();
  const isSeller = offer.item.seller == genSellerId(txCaller);
  const isCarrier =
                offer.bought.is_some &&
                offer.bought.value.selectedCarrierId == genCarrierId(txCaller);
  assert(isSeller || isCarrier, "Only the seller or carrier of the offer can rate the buyer");

  const updatedOffer = Offer { ...offer, buyerRating: disclose(rating) };
  offers.insert(disclose(offer.id), updatedOffer);
  return [];
}

// Check the offer exists and the caller is the buyer
circuit isCallerTheBuyer(offer: Offer): Boolean {
  const buyerId = genBuyerId(ownPublicKey());
  return (offer.bought.is_some && offer.bought.value.buyerId == buyerId);
}

// Check the offer exists and the caller is the selected carrier
circuit isCallerTheCarrier(offer: Offer): Boolean {
  const carrierId = genCarrierId(ownPublicKey());
  return (offer.bought.is_some && offer.bought.value.selectedCarrierId == carrierId);
}

// Check the offer exists and the caller is the seller
circuit isCallerTheSeller(offer: Offer): Boolean {
  const sellerId = genSellerId(ownPublicKey());
  return (offer.item.seller == sellerId);
}

// Generates an Offer ID using the Item's fields
export circuit genOfferId(item: Item): Bytes<32> {
  return persistentHash<Vector<4, Bytes<32>>>(
           [pad(32, "dmarket_offer_id:"), item.id, item.seller, item.price as Bytes<32>]);
}

// Check offer state and return it
circuit checkOfferState(offerId: Bytes<32>, expectedState: TxState): Offer {
  const disclosedOfferId = disclose(offerId);
  assert(offers.member(disclosedOfferId), "Offer not found");
  const offer = offers.lookup(disclosedOfferId);
  if (expectedState == TxState.New) {
    assert(offer.state == expectedState, "Item has already been bought");
  }
  if (expectedState == TxState.Bought) {
    assert(offer.state == expectedState, "Item has not been bought or already picked up");
  }
  if (expectedState == TxState.PickedUp) {
    assert(offer.state == expectedState, "Item has not been bought or already confirmed as picked up");
  }
  if (expectedState == TxState.InTransit) {
    assert(offer.state == expectedState, "Item has been already delivered or it was not yet picked up for delivery");
  }
  if (expectedState == TxState.Delivered) {
    assert(offer.state == expectedState, "The item was already confirmed as delivered, or it has not been delivered yet");
  }
  if (expectedState == TxState.Dispute) {
    assert(offer.state == expectedState, "The item is not marked as being in dispute");
  }
  if (expectedState == TxState.Completed) {
    assert(offer.state == expectedState, "The offer has not been marked as completed yet");
  }

  return offer;
}

// Set Offer state
circuit setOfferState(offer: Offer, newState: TxState): [] {
  const updatedOffer = Offer { ...offer, state: newState };
  offers.insert(offer.id, updatedOffer);
  return [];
}

// TODO: use OpenZeppelin tools.
// Generates a seller ID from a public key.
export circuit genSellerId(pk: ZswapCoinPublicKey): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "dmarket_seller_id:"), pk.bytes]));
}

// TODO: use OpenZeppelin tools.
// Generates a buyer ID from a public key.
export circuit genBuyerId(pk: ZswapCoinPublicKey): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "dmarket_buyer_id:"), pk.bytes]));
}

// TODO: use OpenZeppelin tools.
// Generates a carrier ID from a public key.
export circuit genCarrierId(pk: ZswapCoinPublicKey): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "dmarket_carrier_id:"), pk.bytes]));
}
