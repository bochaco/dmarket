pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

/**** Notes:
- Contract Address Support: Seller, buyer, and carrier roles do not currently support contract addresses.
- Transaction History Storage: While transaction history is being stored, future versions may implement external storage solutions.
- Shielded coins used in dMarket are minted by this same contract, in future version it could be taken out to a separate coin contract.
- Dispute Initiation: Only buyers have the ability to open disputes at present, but future updates will allow carriers to do the same.
- Dispute Resolution: The seller currently acts as the arbitrator for disputes initiated by the buyer. In future versions, an option for selecting an external arbitrator service will be available.

TODO:
- Anonymization: Implement anonymization for sellers, buyers, and carriers using OpenZeppelin tools.
- Testing: Develop tests for circuit functionality to check states.
- Allow to specify type of dispute and type of resolution.
- Deposits management for dispute resolutions.
- Encrypt delivery address to the selected carrier's PK
- Check ratings are not greater than 255
- Store reason of dispute and type of resolution
****/

// Information kept for registered carriers
export struct Carrier {
  // Unique ID of the carrier
  id: Bytes<32>,
  // Wallet of the carrier where fees payment shall be sent.
  wallet: ZswapCoinPublicKey,
  // Optional metadata, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>
}

// Information kept for registered sellers
export struct Seller {
  // Unique ID of the carrier
  id: Bytes<32>,
  // Wallet of the seller where payments shall be sent.
  wallet: ZswapCoinPublicKey,
  // Optional metadata, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>
}

// Maps carriers and sellers IDs to their registered information.
// Updated only when a offer gets completed.
export ledger carriers: Map<Bytes<32>, Carrier>;

export ledger sellers: Map<Bytes<32>, Seller>;

// The locked deposits made by users of offers being fulfilled.
export ledger treasury: QualifiedCoinInfo;

// Flag to keep track whether there are coins stored on the treasury.
ledger treasuryWithCoins: Boolean;

// Domain separator used to mint the shielded tokens
export ledger coinDomainSeparator: Bytes<32>;

// Counter and nonce are both used to generate a nonce when minting new shielded coins
export ledger mintCounter: Counter;

export ledger mintNonce: Bytes<32>;

// Total number of ever minted shielded coins by this contract
export ledger totalMinted: Uint<64>;

// Type to track the state of each published offer
export enum OfferState {
  // New offer created and published.
  New,
  // A buyer selected the offer and made the deposit.
  Purchased,
  // The carrier accepted and made the deposit.
  PickedUp,
  // The seller confirmed the item was picked up by the carrier for deivery. The seller
  // may request a signature to the carrier, generated by the dApp with
  // the carrier ID, to verify he/she is the effectivelly the carrier selected by the buyer.
  InTransit,
  // The carrier declares to have delivered the good/item. The carrier may request
  // a signature to the buyer, generated by the dApp with buyer ID, to confirm he/she is effectively the buyer.
  Delivered,
  // The buyer has opened a dispute which will need to be solved by the seller.
  Dispute,
  // Either the buyer confirmed the good/item was delivered and happy with it, or
  // a dispute was opened and already resolved by the seller.
  Completed
}

// Information defined when an offer is purchased, including selected carrier and agreed fee
export struct PurchaseDetails {
  buyerId: Bytes<32>,
  selectedCarrierId: Bytes<32>,
  carrierFee: Uint<128>
}

// Published offer
export struct Offer {
  // ID of the offer
  id: Bytes<32>,
  // Price of the offered good/item.
  price: Uint<128>,
  // Optional metadata for the item, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>,
  // Current state of the offer
  state: OfferState,
  // ID of the seller.
  seller: Bytes<32>,
  // A tuple containing the buyer ID, the selected carrier ID, and the fee price.
  purchaseDetails: Maybe<PurchaseDetails>,
  // Estimated time of arrival (timestamp) of the item
  // Only the chosen carrier can set/update this value.
  deliveryEta: Uint<128>,
  // Rating given to the seller, by the carrier and buyer respectively.
  sellerRatings: [Uint<8>, Uint<8>],
  // Rating given to the carrier, by the seller and buyer respectively.
  carrierRatings: [Uint<8>, Uint<8>],
  // Rating given to the buyer, by the seller and carrier respectively.
  buyerRatings: [Uint<8>, Uint<8>],
}

// Maps offers IDs to their info including state.
export ledger offers: Map<Bytes<32>, Offer>;

// Maps the offer IDs to the carriers offered to deliver the item and their bidding fee price.
export ledger carrierBids: Map<Bytes<32>, Map<Bytes<32>, Uint<128>>>;

// Construction circuit, where coin domain separator and color are defined.
// An initial nonce is provided which is then to generate new nonces for coin minting.
constructor(initNonce: Bytes<32>) {
  mintNonce = disclose(initNonce);
  coinDomainSeparator = pad(32, "dmarket_shielded_coin");
}

// Mint shielded coins to be owned by the caller
export circuit mintCoins(): [] {
  // everyone can mint 1000 shielded tokens to themselves each time.
  mintCounter.increment(1);
  const newNonce = evolveNonce(mintCounter, mintNonce);
  const amount: Uint<64> = 10000;

  totalMinted = totalMinted + amount as Uint<64>;
  mintToken(
    coinDomainSeparator,
    amount,
    newNonce,
    left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));

  mintNonce = newNonce;
}

// Creates a new public offer for a given item.
// OfferState: () => New
export circuit offerItem(
                 itemId: Bytes<32>,
                 price: Uint<128>,
                 itemMeta: Opaque<'string'>,
                 sellerMeta: Opaque<'string'>
                 ): Offer {
  const sellerId = genSellerId(ownPublicKey());
  const offerId = genOfferId(sellerId, itemId, price);
  const disclosedOfferId = disclose(offerId);
  assert(!offers.member(disclosedOfferId), "Offer already exists");

  if (!sellers.member(sellerId)) {
    // TODO: require the seller to be already registered
    sellers.insert(
      sellerId, Seller { id: sellerId, wallet: ownPublicKey(), meta: disclose(sellerMeta) });
  }
  const offer = Offer { ...default<Offer>,
                        id: offerId,
                        price: price,
                        meta: itemMeta,
                        seller: sellerId,
                        state: OfferState.New };
  offers.insert(disclosedOfferId, disclose(offer));
  return offer;
}

// Adds a new carrier fee bid to an already published offer.
// Buyers will then be able to select a carrier among the bidders when buying the item.
// OfferState: New => New
export circuit setCarrierBid(offerId: Bytes<32>, fee: Uint<128>, carrierMeta: Opaque<'string'>): [] {
  const offer = checkOfferState(offerId, OfferState.New);

  const carrierId = genCarrierId(ownPublicKey());
  if (!carriers.member(carrierId)) {
    // TODO: request the carrier to be already registered
    carriers.insert(
      carrierId, Carrier { id: carrierId, wallet: ownPublicKey(), meta: disclose(carrierMeta) });
  }

  if (!carrierBids.member(offer.id)) {
    carrierBids.insert(offer.id, default<Map<Bytes<32>, Uint<128>>>);
  }

  carrierBids.lookup(offer.id).insert(carrierId, disclose(fee));
}

// Update the estimated time of arrival (ETA) of an offer already in transit.
// OfferState: InTransit => InTransit
export circuit setOfferEta(offerId: Bytes<32>, timestamp: Uint<128>): [] {
  const offer = checkOfferState(offerId, OfferState.InTransit);
  assert(isCallerTheCarrier(offer), "Only the carrier selected for an offer can set its delivery ETA");

  const updatedOffer = Offer { ...offer, deliveryEta: disclose(timestamp) };
  offers.insert(offer.id, updatedOffer);
}

// Purchase the item of a published offer, prodiving the ID of the carrier
// selected among the current fee bidders. Only the selected carrier can
// then pick up the item for delivery.
// OfferState: New => Purchased
export circuit purchaseItem(offerId: Bytes<32>, carrierId: Bytes<32>, coinInfo: CoinInfo): [] {
  const offer = checkOfferState(offerId, OfferState.New);

  assert(carrierBids.member(offer.id), "No carriers found for the offer");
  const disclosedCarrierId = disclose(carrierId);
  assert(carrierBids.lookup(offer.id).member(disclosedCarrierId), "Carrier not found among bidders");
  const fee = carrierBids.lookup(offer.id).lookup(disclosedCarrierId);
  assert(coinInfo.value == offer.price + fee, "Deposit amount must be equal to the item price plus the carrier fee");

  // deposit according to price and carrier fee
  receiveDeposit(coinInfo);

  const buyerId = genBuyerId(ownPublicKey());
  const purchaseDetails =
                some<PurchaseDetails>(
                  PurchaseDetails { buyerId: buyerId,
                                    selectedCarrierId: disclosedCarrierId,
                                    carrierFee: fee });
  const updatedOffer =
                Offer { ...offer, purchaseDetails: purchaseDetails, state: OfferState.Purchased };
  offers.insert(offer.id, updatedOffer);
  carrierBids.remove(offer.id);
}

// Item is being picked up by the selected carrier, changing the offer state,
// and locking the deposit made by the carrier according to the item's price.
// OfferState: Purchased => PickedUp
export circuit itemPickedUp(offerId: Bytes<32>, coinInfo: CoinInfo, eta: Maybe<Uint<128>>): [] {
  const offer = checkOfferState(offerId, OfferState.Purchased);
  assert(isCallerTheCarrier(offer), "Only the selected carrier can pick this item up for delivery");

  // deposit according to price and carrier fee
  const fee = offer.purchaseDetails.value.carrierFee;
  assert(coinInfo.value == offer.price + fee, "Deposit amount must be equal to the item price plus the carrier fee");
  receiveDeposit(coinInfo);

  if (disclose(eta.is_some)) {
     setOfferState(Offer { ...offer, deliveryEta: disclose(eta.value) }, OfferState.PickedUp);
  } else {
     setOfferState(offer, OfferState.PickedUp);
  }
}

// The seller confirms the carrier has picked the item up for delivery.
// The seller may request the carrier to proove it's the selected carrier for the offer beforehand.
// OfferState: PickedUp => InTransit
export circuit confirmItemInTransit(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.PickedUp);
  assert(isCallerTheSeller(offer), "Only the seller can confirm the item has been picked up for delivery");

  setOfferState(offer, OfferState.InTransit);
}

// The carrier declares it has delivered the item to the buyer.
// The carrier may request the buyer to proove it's the buyer of the offer beforehand.
// OfferState: InTransit => Delivered
export circuit delivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.InTransit);
  assert(isCallerTheCarrier(offer), "Only the carrier can set the item as delivered");

  setOfferState(offer, OfferState.Delivered);
}

// The buyer confirms it received the purchased item and no dispute needs to be opened.
// OfferState: Delivered => Completed
export circuit confirmDelivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Delivered);
  assert(isCallerTheBuyer(offer), "Only the buyer can confirm the item has been delivered");

  // release deposits to carrier, plus the owned carrier fee
  const fee = offer.purchaseDetails.value.carrierFee;
  const amount = offer.price + fee + fee;
  const carrier = carriers.lookup(offer.purchaseDetails.value.selectedCarrierId);
  sendPayment(carrier.wallet, amount as Uint<128>);

  // release deposits to seller
  const seller = sellers.lookup(offer.seller);
  sendPayment(seller.wallet, offer.price);

  setOfferState(offer, OfferState.Completed);
}

// The buyer opens a dispute on the item it received.
// OfferState: Delivered => Dispute
// TODO: allow to dispute when it was not delivered but intransit
export circuit disputeItem(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Delivered);
  assert(isCallerTheBuyer(offer), "Only the buyer can open a dispute on the item");

  setOfferState(offer, OfferState.Dispute);
}

// The seller resolves a dispute.
// OfferState: Dispute => Completed
export circuit resolveDispute(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Dispute);
  assert(isCallerTheSeller(offer), "Only the seller can resolve a dispute");

  // TODO: relese deposits and apply confiscations accordingly

  setOfferState(offer, OfferState.Completed);
}

// The carrier or buyer of the offer can rate the seller, and only once.
// OfferState: Completed => Completed
export circuit rateSeller(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isBuyer = isCallerTheBuyer(offer);
  const isCarrier = isCallerTheCarrier(offer);
  assert(isCarrier || isBuyer, "Only the carrier or buyer of the offer can rate the seller");

  if (isCarrier) {
    assert(offer.sellerRatings[0] == 0, "The rate for the seller was already set by the carrier");
    const updatedOffer =
                  Offer { ...offer, sellerRatings: [disclose(rating), offer.sellerRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isBuyer) {
    assert(offer.sellerRatings[1] == 0, "The rate for the seller was already set by the buyer");
    const updatedOffer =
                  Offer { ...offer, sellerRatings: [offer.sellerRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

// The buyer or seller of the offer can rate the carrier, and only once.
// OfferState: Completed => Completed
export circuit rateCarrier(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isBuyer = isCallerTheBuyer(offer);
  const isSeller = isCallerTheSeller(offer);
  assert(isSeller || isBuyer, "Only the seller or buyer of the offer can rate the carrier");

  if (isSeller) {
    assert(offer.carrierRatings[0] == 0, "The rate for the carrier was already set by the seller");
    const updatedOffer =
                  Offer { ...offer, carrierRatings: [disclose(rating), offer.carrierRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isBuyer) {
    assert(offer.carrierRatings[1] == 0, "The rate for the carrier was already set by the buyer");
    const updatedOffer =
                  Offer { ...offer, carrierRatings: [offer.carrierRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

// The carrier or seller of the offer can rate the buyer, and only once.
// OfferState: Completed => Completed
export circuit rateBuyer(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isCarrier = isCallerTheCarrier(offer);
  const isSeller = isCallerTheSeller(offer);
  assert(isSeller || isCarrier, "Only the seller or carrier of the offer can rate the buyer");

  if (isSeller) {
    assert(offer.buyerRatings[0] == 0, "The rate for the buyer was already set by the seller");
    const updatedOffer = Offer { ...offer, buyerRatings: [disclose(rating), offer.buyerRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isCarrier) {
    assert(offer.buyerRatings[1] == 0, "The rate for the buyer was already set by the carrier");
    const updatedOffer = Offer { ...offer, buyerRatings: [offer.buyerRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

// Check the caller is the buyer
circuit isCallerTheBuyer(offer: Offer): Boolean {
  const buyerId = genBuyerId(ownPublicKey());
  return (offer.purchaseDetails.is_some && offer.purchaseDetails.value.buyerId == buyerId);
}

// Check the caller is the selected carrier
circuit isCallerTheCarrier(offer: Offer): Boolean {
  const carrierId = genCarrierId(ownPublicKey());
  return (offer.purchaseDetails.is_some &&
          offer.purchaseDetails.value.selectedCarrierId == carrierId);
}

// Check the caller is the seller
circuit isCallerTheSeller(offer: Offer): Boolean {
  const sellerId = genSellerId(ownPublicKey());
  return (offer.seller == sellerId);
}

// Generates an Offer ID using the item's id, price, and seller ID
export circuit genOfferId(sellerId: Bytes<32>, itemId: Bytes<32>, price: Uint<128>): Bytes<32> {
  return persistentHash<Vector<4, Bytes<32>>>(
           [pad(32, "dmarket_offer_id:"), sellerId, itemId, price as Bytes<32>]);
}

// Check offer state and return it
circuit checkOfferState(offerId: Bytes<32>, expectedState: OfferState): Offer {
  const disclosedOfferId = disclose(offerId);
  assert(offers.member(disclosedOfferId), "Offer not found");
  const offer = offers.lookup(disclosedOfferId);
  if (expectedState == OfferState.New) {
    assert(offer.state == expectedState, "Item has already been purchased");
  }
  if (expectedState == OfferState.Purchased) {
    assert(offer.state == expectedState, "Item has not been purchased or already picked up");
  }
  if (expectedState == OfferState.PickedUp) {
    assert(offer.state == expectedState, "Item has not been purchased or already confirmed as picked up");
  }
  if (expectedState == OfferState.InTransit) {
    assert(offer.state == expectedState, "Item has been already delivered or it was not yet picked up for delivery");
  }
  if (expectedState == OfferState.Delivered) {
    assert(offer.state == expectedState, "The item was already confirmed as delivered, or it has not been delivered yet");
  }
  if (expectedState == OfferState.Dispute) {
    assert(offer.state == expectedState, "The item is not marked as being in dispute");
  }
  if (expectedState == OfferState.Completed) {
    assert(offer.state == expectedState, "The offer has not been marked as completed yet");
  }

  return offer;
}

// Set Offer state
circuit setOfferState(offer: Offer, newState: OfferState): [] {
  const updatedOffer = Offer { ...offer, state: newState };
  offers.insert(offer.id, updatedOffer);
}

// TODO: use OpenZeppelin tools.
// Generates a seller ID from a public key.
export circuit genSellerId(pk: ZswapCoinPublicKey): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "dmarket_seller_id:"), pk.bytes]));
}

// TODO: use OpenZeppelin tools.
// Generates a buyer ID from a public key.
export circuit genBuyerId(pk: ZswapCoinPublicKey): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "dmarket_buyer_id:"), pk.bytes]));
}

// TODO: use OpenZeppelin tools.
// Generates a carrier ID from a public key.
export circuit genCarrierId(pk: ZswapCoinPublicKey): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "dmarket_carrier_id:"), pk.bytes]));
}

// Receive a deposit and keep it in this contract's teasury
circuit receiveDeposit(coinInfo: CoinInfo): [] {
  // receive only dMarket color coins
  const myCoinColor = tokenType(coinDomainSeparator, disclose(kernel.self()));
  assert(coinInfo.color == myCoinColor, "Only dMarket coins can be used for payments");

  receive(disclose(coinInfo));
  const me = right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
  if (!treasuryWithCoins) {
     treasury.writeCoin(disclose(coinInfo), me);
     treasuryWithCoins = true;
  } else {
     const mergedCoin = mergeCoinImmediate(treasury, disclose(coinInfo));
     treasury.writeCoin(disclose(mergedCoin), me);
  }
}

// Send a payment to the given PK and amount
circuit sendPayment(to: ZswapCoinPublicKey, amount: Uint<128>): [] {
  const wallet = left<ZswapCoinPublicKey, ContractAddress>(to);
  const sendResult = send(treasury, wallet, disclose(amount));
  assert(sendResult.sent.value == amount, "Failed to send payment");
  const me = right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
  if (sendResult.change.is_some) {
     treasury.writeCoin(sendResult.change.value, me);
  } else {
     treasuryWithCoins = false;
     treasury.resetToDefault();
  }
}
