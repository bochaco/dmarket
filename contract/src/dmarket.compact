pragma language_version >= 0.20.0;

import CompactStandardLibrary;

import "./Types";

export { Offer, Carrier, Seller, OfferState, PurchaseDetails };

import "./Coins";

export { mintCoins, treasury, totalMinted, coinDomainSeparator };

import "./Utils" prefix Utils_;

export { Utils_genBuyerId, Utils_genCarrierId, Utils_genSellerId, Utils_genOfferId };

/**
 * DMarket Contract — high level notes
 *
 * Purpose:
 * - Implements a privacy-preserving marketplace for physical goods where buyers, sellers
 *   and carriers interact using shielded coins and obfuscated identifiers.
 * - Handles publishing offers, carrier bidding, purchase flow, delivery lifecycle, ratings
 *   and basic dispute resolution.
 *
 * Important design points / limitations:
 * - Roles (seller, buyer, carrier) use shielded/obfuscated identifiers derived from a
 *   user's public key and a local `secretKey()` witness — contract addresses are not
 *   supported as role identities today.
 * - Transaction history and item metadata are stored in the ledger; larger deployments
 *   may move heavy metadata to external storage and store only references on-chain.
 * - Shielded coins minted by this contract are used for payments; the minting logic
 *   currently lives in `Coins.compact` within the same package but could be split out.
 * - Disputes may only be opened by buyers today; dispute resolution is performed by
 *   the seller in the current workflow (simple example resolution implemented).
 *
 * Future work (non-exhaustive):
 * - More flexible deposit/fund distribution rules for dispute outcomes.
 * - Allow carriers to declare alternative delivery options and pricing tiers.
 * - Enable external arbitrators and richer dispute metadata (reason, resolution type).
 */

// Maps carriers IDs to their registered information.
export ledger carriers: Map<Bytes<32>, Carrier>;

// Maps sellers IDs to their registered information.
export ledger sellers: Map<Bytes<32>, Seller>;

// Maps offers IDs to their info including state.
export ledger offers: Map<Bytes<32>, Offer>;

// Maps the offer IDs to the carriers offered to deliver the
// item and their bidding fee price.
export ledger carrierBids: Map<Bytes<32>, Map<Bytes<32>, Uint<128>>>;

/**
 * @witness secretKey
 * @description A private per-user nonce used in deriving the shielded user identifiers.
 * Combined with the user's public key to produce an obfuscated, unlinkable identity commitment.
 */
witness secretKey(): Bytes<32>;

/**
 * @witness encrypt
 * @description Encryption function used to encrypt the delivery address to
 * the selected carrier's encryption key.
 */
witness encrypt(data: Opaque<'string'>, encryptionPk: Opaque<'string'>): Opaque<'string'>;

// Construction circuit, where coin domain separator and color are defined.
// An initial nonce is provided which is then to generate new nonces for coin minting.
constructor(initNonce: Bytes<32>) {
  initialise(initNonce);
}

/**
 * Publish a new `Offer` for an item.
 *
 * Effects:
 * - Derives the `sellerId` from the caller's public key + `secretKey()` witness.
 * - Creates a `Seller` entry if the calling seller is not already registered.
 * - Inserts a new `Offer` in `offers` ledger keyed by `offerId`.
 *
 * Preconditions:
 * - There must not already be an offer with the same `offerId`.
 *
 * Postconditions:
 * - The returned `Offer` struct represents the stored offer in `OfferState.New` state.
 *
 * Parameters:
 * - `itemId`: unique item identifier (Bytes<32>).
 * - `price`: asking price in shielded coin units (Uint<128>).
 * - `itemMeta`: opaque metadata for the item (e.g. JSON string).
 * - `sellerMeta`: opaque metadata for the seller (stored disclosed for lookup).
 */
export circuit offerItem(
                 itemId: Bytes<32>,
                 price: Uint<128>,
                 itemMeta: Opaque<'string'>,
                 sellerMeta: Opaque<'string'>
                 ): Offer {
  const sellerId = Utils_genSellerId(ownPublicKey(), secretKey(), kernel.self().bytes);
  const offerId = Utils_genOfferId(sellerId, itemId, price);
  const dOfferId = disclose(offerId);
  assert(!offers.member(dOfferId), "Offer already exists");

  if (!sellers.member(sellerId)) {
    // TODO: require the seller to be already registered
    sellers.insert(
      sellerId, Seller { id: sellerId, wallet: ownPublicKey(), meta: disclose(sellerMeta) });
  }
  const offer = Offer { ...default<Offer>,
                        id: offerId,
                        price: price,
                        meta: itemMeta,
                        seller: sellerId,
                        state: OfferState.New };
  offers.insert(dOfferId, disclose(offer));
  return offer;
}

/**
 * Register or update a carrier's bid (fee) for an existing `Offer`.
 *
 * Effects:
 * - Ensures the `Offer` is in `OfferState.New`.
 * - Derives `carrierId` from the caller and registers the carrier if new.
 * - Inserts/updates `carrierBids[offerId][carrierId] = fee`.
 *
 * Preconditions:
 * - `offerId` must reference an existing offer in `New` state.
 *
 * Notes:
 * - `encryptionPk` is disclosed and stored for future delivery address encryption.
 * - `carrierMeta` is disclosed for off-chain discovery; both are stored disclosed.
 */
export circuit setCarrierBid(
                 offerId: Bytes<32>,
                 fee: Uint<128>,
                 encryptionPk: Opaque<'string'>,
                 carrierMeta: Opaque<'string'>
                 ): [] {
  const offer = checkOfferState(offerId, OfferState.New);

  const carrierId = Utils_genCarrierId(ownPublicKey(), secretKey(), kernel.self().bytes);
  if (!carriers.member(carrierId)) {
    // TODO: request the carrier to be already registered
    carriers.insert(
      carrierId,
      Carrier { id: carrierId,
                wallet: ownPublicKey(),
                encryptionPk: disclose(encryptionPk),
                meta: disclose(carrierMeta) });
  }

  if (!carrierBids.member(offer.id)) {
    carrierBids.insert(offer.id, default<Map<Bytes<32>, Uint<128>>>);
  }

  carrierBids.lookup(offer.id).insert(carrierId, disclose(fee));
}

/**
 * Update the delivery ETA for an offer currently `InTransit`.
 *
 * Preconditions:
 * - Caller must be the selected carrier for the `offer`.
 * - The offer must be in `OfferState.InTransit`.
 *
 * Effects:
 * - Updates `offer.deliveryEta` with the disclosed `timestamp` value.
 */
export circuit setOfferEta(offerId: Bytes<32>, timestamp: Uint<128>): [] {
  const offer = checkOfferState(offerId, OfferState.InTransit);
  assert(Utils_isCallerTheCarrier(offer, secretKey()), "Only the carrier selected for an offer can set its delivery ETA");

  const updatedOffer = Offer { ...offer, deliveryEta: disclose(timestamp) };
  offers.insert(offer.id, updatedOffer);
}

/**
 * Purchase an `Offer` and select a carrier from the existing bids.
 *
 * Preconditions:
 * - `offer` must be in `OfferState.New`.
 * - `carrierId` must be one of the bidders for the offer.
 * - `coinInfo.value` must equal `offer.price + carrierFee` (deposit from buyer).
 *
 * Effects:
 * - Receives/burns/mints shielded `coinInfo` via `receiveDeposit` (escrow behavior).
 * - Stores `purchaseDetails` in the `Offer` including an encrypted delivery address
 *   using the carrier's `encryptionPk`.
 * - Transitions the offer to `OfferState.Purchased` and removes the carrier bids map.
 *
 * Parameters:
 * - `deliveryAddress` is encrypted with the selected carrier's public key using
 *   the `encrypt` witness before being stored in the ledger.
 */
export circuit purchaseItem(
                 offerId: Bytes<32>,
                 carrierId: Bytes<32>,
                 coinInfo: ShieldedCoinInfo,
                 deliveryAddress: Opaque<'string'>
                 ): [] {
  const offer = checkOfferState(offerId, OfferState.New);

  assert(carrierBids.member(offer.id), "No carriers found for the offer");
  const dCarrierId = disclose(carrierId);
  assert(carrierBids.lookup(offer.id).member(dCarrierId), "Carrier not found among bidders");
  assert(carriers.member(dCarrierId), "Carrier is not registered");
  const encryptionPk = carriers.lookup(dCarrierId).encryptionPk;
  const fee = carrierBids.lookup(offer.id).lookup(dCarrierId);
  assert(coinInfo.value == offer.price + fee, "Deposit amount must be equal to the item price plus the carrier fee");

  // deposit according to price and carrier fee
  receiveDeposit(coinInfo);

  const buyerId = Utils_genBuyerId(ownPublicKey(), secretKey(), kernel.self().bytes);
  const purchaseDetails =
                some<PurchaseDetails>(
                  PurchaseDetails { buyerId: buyerId,
                                    refundWallet: ownPublicKey(),
                                    selectedCarrierId: dCarrierId,
                                    carrierFee: fee,
                                    deliveryAddress: disclose(encrypt(deliveryAddress, encryptionPk)) });
  const updatedOffer =
                Offer { ...offer, purchaseDetails: purchaseDetails, state: OfferState.Purchased };
  offers.insert(offer.id, updatedOffer);
  carrierBids.remove(offer.id);
}

/**
 * Carrier picks up the item for delivery.
 *
 * Preconditions:
 * - Offer must be `Purchased` and caller must be the selected carrier.
 * - `coinInfo.value` must equal `offer.price + carrierFee` (carrier posts matching deposit).
 *
 * Effects:
 * - Receives carrier deposit into escrow via `receiveDeposit`.
 * - Optionally sets `deliveryEta` if provided.
 * - Transitions the offer to `OfferState.PickedUp`.
 */
export circuit itemPickedUp(offerId: Bytes<32>, coinInfo: ShieldedCoinInfo, eta: Maybe<Uint<128>>): [] {
  const offer = checkOfferState(offerId, OfferState.Purchased);
  assert(Utils_isCallerTheCarrier(offer, secretKey()), "Only the selected carrier can pick this item up for delivery");

  // deposit should be equal to the amount deposited by the buyer, i.e. item's price + delviery fee
  const fee = offer.purchaseDetails.value.carrierFee;
  assert(coinInfo.value == offer.price + fee, "Deposit amount must be equal to the item price plus the carrier fee");
  receiveDeposit(coinInfo);

  if (disclose(eta.is_some)) {
     setOfferState(Offer { ...offer, deliveryEta: disclose(eta.value) }, OfferState.PickedUp);
  } else {
     setOfferState(offer, OfferState.PickedUp);
  }
}

/**
 * Seller confirms the carrier picked up the item; moves to `InTransit`.
 *
 * Preconditions:
 * - Offer must be `PickedUp` and caller must be the seller of the offer.
 *
 * Effects:
 * - Transitions the offer to `OfferState.InTransit`.
 */
export circuit confirmItemInTransit(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.PickedUp);
  assert(Utils_isCallerTheSeller(offer, secretKey()), "Only the seller can confirm the item has been picked up for delivery");

  setOfferState(offer, OfferState.InTransit);
}

/**
 * Carrier marks the offer as `Delivered` once delivery is completed.
 *
 * Preconditions:
 * - Offer must be `InTransit` and caller must be the selected carrier.
 *
 * Effects:
 * - Transitions the offer to `OfferState.Delivered`.
 */
export circuit delivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.InTransit);
  assert(Utils_isCallerTheCarrier(offer, secretKey()), "Only the carrier can set the item as delivered");

  setOfferState(offer, OfferState.Delivered);
}

/**
 * Buyer confirms successful delivery and triggers final fund distribution.
 *
 * Preconditions:
 * - Offer must be `Delivered` and caller must be the buyer.
 *
 * Effects:
 * - Releases payments: sends the carrier deposit (including fee) and the seller payment.
 * - Transitions the offer to `OfferState.Completed`.
 *
 * Notes:
 * - The current payment calculation uses `amount = offer.price + fee + fee` where the
 *   carrier receives both deposits and its fee; see `sendPayments` usage for specifics.
 */
export circuit confirmDelivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Delivered);
  assert(Utils_isCallerTheBuyer(offer, secretKey()), "Only the buyer can confirm the item has been delivered");

  // release payment to seller, deposits to carrier, plus the owned carrier fee
  const fee = offer.purchaseDetails.value.carrierFee;
  const amount = offer.price + fee + fee;
  const carrier = carriers.lookup(offer.purchaseDetails.value.selectedCarrierId);
  const seller = sellers.lookup(offer.seller);
  const carrierWallet = left<ZswapCoinPublicKey, ContractAddress>(carrier.wallet);
  const sellerWallet = left<ZswapCoinPublicKey, ContractAddress>(seller.wallet);
  sendPayments(carrierWallet, amount as Uint<128>, sellerWallet, offer.price);

  setOfferState(offer, OfferState.Completed);
}

/**
 * Buyer opens a dispute about the delivered item.
 *
 * Preconditions:
 * - Offer must be `Delivered` and caller must be the buyer.
 *
 * Effects:
 * - Transitions the offer to `OfferState.Dispute`.
 *
 * TODO:
 * - Allow dispute to be opened when an item is `InTransit` (not yet delivered).
 */
export circuit disputeItem(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Delivered);
  assert(Utils_isCallerTheBuyer(offer, secretKey()), "Only the buyer can open a dispute on the item");

  setOfferState(offer, OfferState.Dispute);
}

/**
 * Seller resolves a dispute. Current implementation demonstrates one resolution
 * type: compensate the buyer and punish the carrier by burning part of their deposit.
 *
 * Preconditions:
 * - Offer must be `Dispute` and caller must be the seller.
 *
 * Effects:
 * - Refunds buyer (buyer refund wallet) and burns a portion of carrier funds as illustrated.
 * - Transitions the offer to `OfferState.Completed`.
 *
 * Notes:
 * - This is a simplified example. Real-world dispute resolution should handle multiple
 *   resolution types and configurable confiscation/compensation rules.
 */
export circuit resolveDispute(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Dispute);
  assert(Utils_isCallerTheSeller(offer, secretKey()), "Only the seller can resolve a dispute");

  // TODO: relese deposits and apply confiscations according to different resolution types.
  // Currently, just as a demonstration of one type of resolution action to be taken by this circuit,
  // we refund the buyer plus the delivery fee deposited by the carrier as a compensation,
  // and burn the rest of the funds that were deposited by the carrier, which is equal to item's price.

  const refundAmount = offer.price + 2 * offer.purchaseDetails.value.carrierFee as Uint<128>;
  const refundWallet =
                left<ZswapCoinPublicKey, ContractAddress>(offer.purchaseDetails.value.refundWallet);
  sendPayments(refundWallet, refundAmount, shieldedBurnAddress(), offer.price);

  setOfferState(offer, OfferState.Completed);
}

/**
 * Submit a rating for the `seller` by either the buyer or the carrier (once each).
 *
 * Preconditions:
 * - Offer must be `Completed`.
 * - Caller must be either the buyer or the carrier.
 * - Rating must be in range (0,255].
 *
 * Effects:
 * - Stores revealed rating in the offer's `sellerRatings` array depending on caller role.
 */
export circuit rateSeller(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0 and smaller than 256");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isBuyer = Utils_isCallerTheBuyer(offer, secretKey());
  const isCarrier = Utils_isCallerTheCarrier(offer, secretKey());
  assert(isCarrier || isBuyer, "Only the carrier or buyer of the offer can rate the seller");

  if (isCarrier) {
    assert(offer.sellerRatings[0] == 0, "The rate for the seller was already set by the carrier");
    const updatedOffer =
                  Offer { ...offer, sellerRatings: [disclose(rating), offer.sellerRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isBuyer) {
    assert(offer.sellerRatings[1] == 0, "The rate for the seller was already set by the buyer");
    const updatedOffer =
                  Offer { ...offer, sellerRatings: [offer.sellerRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

/**
 * Submit a rating for the `carrier` by either the buyer or the seller (once each).
 *
 * Preconditions:
 * - Offer must be `Completed`.
 * - Caller must be buyer or seller.
 *
 * Effects:
 * - Stores the rating in `carrierRatings` based on caller role.
 */
export circuit rateCarrier(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0 and smaller than 256");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isBuyer = Utils_isCallerTheBuyer(offer, secretKey());
  const isSeller = Utils_isCallerTheSeller(offer, secretKey());
  assert(isSeller || isBuyer, "Only the seller or buyer of the offer can rate the carrier");

  if (isSeller) {
    assert(offer.carrierRatings[0] == 0, "The rate for the carrier was already set by the seller");
    const updatedOffer =
                  Offer { ...offer, carrierRatings: [disclose(rating), offer.carrierRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isBuyer) {
    assert(offer.carrierRatings[1] == 0, "The rate for the carrier was already set by the buyer");
    const updatedOffer =
                  Offer { ...offer, carrierRatings: [offer.carrierRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

/**
 * Submit a rating for the `buyer` by either the carrier or the seller (once each).
 *
 * Preconditions:
 * - Offer must be `Completed`.
 * - Caller must be seller or carrier.
 *
 * Effects:
 * - Stores the rating in `buyerRatings` based on caller role.
 */
export circuit rateBuyer(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0 and smaller than 256");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isCarrier = Utils_isCallerTheCarrier(offer, secretKey());
  const isSeller = Utils_isCallerTheSeller(offer, secretKey());
  assert(isSeller || isCarrier, "Only the seller or carrier of the offer can rate the buyer");

  if (isSeller) {
    assert(offer.buyerRatings[0] == 0, "The rate for the buyer was already set by the seller");
    const updatedOffer = Offer { ...offer, buyerRatings: [disclose(rating), offer.buyerRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isCarrier) {
    assert(offer.buyerRatings[1] == 0, "The rate for the buyer was already set by the carrier");
    const updatedOffer = Offer { ...offer, buyerRatings: [offer.buyerRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

/**
 * Validate an `Offer` exists and assert it is in `expectedState`.
 *
 * Returns the `Offer` if checks pass.
 *
 * This helper centralizes common state checks and improves error messages for callers.
 */
export circuit checkOfferState(offerId: Bytes<32>, expectedState: OfferState): Offer {
  const dOfferId = disclose(offerId);
  assert(offers.member(dOfferId), "Offer not found");
  const offer = offers.lookup(dOfferId);
  if (expectedState == OfferState.New) {
    assert(offer.state == expectedState, "Item has already been purchased");
  }
  if (expectedState == OfferState.Purchased) {
    assert(offer.state == expectedState, "Item has not been purchased or already picked up");
  }
  if (expectedState == OfferState.PickedUp) {
    assert(offer.state == expectedState, "Item has not been purchased or already confirmed as picked up");
  }
  if (expectedState == OfferState.InTransit) {
    assert(offer.state == expectedState, "Item has been already delivered or it was not yet picked up for delivery");
  }
  if (expectedState == OfferState.Delivered) {
    assert(offer.state == expectedState, "The item was already confirmed as delivered, or it has not been delivered yet");
  }
  if (expectedState == OfferState.Dispute) {
    assert(offer.state == expectedState, "The item is not marked as being in dispute");
  }
  if (expectedState == OfferState.Completed) {
    assert(offer.state == expectedState, "The offer has not been marked as completed yet");
  }

  return offer;
}

/**
 * Internal helper to update an `Offer`'s `state`.
 *
 * Notes:
 * - Accepts the `Offer` struct (already read from ledger) and writes back an updated copy.
 */
circuit setOfferState(offer: Offer, newState: OfferState): [] {
  const updatedOffer = Offer { ...offer, state: newState };
  offers.insert(offer.id, updatedOffer);
}
