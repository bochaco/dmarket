pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

import "./Types";

export { Offer, Carrier, Seller, OfferState, PurchaseDetails };

import "./Coins";

export { mintCoins, treasury, totalMinted, coinDomainSeparator };

import "./Utils" prefix Utils_;

export { Utils_genBuyerId, Utils_genCarrierId, Utils_genSellerId, Utils_genOfferId };

/**
* @notes:
* - Contract Address Support: Seller, buyer, and carrier roles do not currently support contract addresses.
* - Transaction History Storage: While transaction history is currently being stored and kept in
* the ledger, future versions may implement external storage solutions. Same for items' metadata.
* - Shielded coins used in dMarket are minted by this same contract, in future version
* it could be taken out to a separate Coin dedicated contract.
* - Dispute Initiation: Only buyers have the ability to open disputes at present, but future
* updates will allow carriers to do the same.
* - Dispute Resolution: The seller currently acts as the arbitrator for disputes initiated by
* the buyer. In future versions, selecting an external arbitrator service can be made available.
*
* @todo:
* - Deposits management/distribution for dispute resolutions.
* - Allow the seller to set the item's pickup location, for carriers to calculate their proposed fee.
* - Allow carriers to provide details of different delivery options, with different destination areas
* and/or distances, as part of the bidding process.
* - Allow to store the type of dispute and type of resolution in the ledger.
* - Allow sellers to pay for all or part of the carrier's fee
**/

// Maps carriers IDs to their registered information.
export ledger carriers: Map<Bytes<32>, Carrier>;

// Maps sellers IDs to their registered information.
export ledger sellers: Map<Bytes<32>, Seller>;

// Maps offers IDs to their info including state.
export ledger offers: Map<Bytes<32>, Offer>;

// Maps the offer IDs to the carriers offered to deliver the
// item and their bidding fee price.
export ledger carrierBids: Map<Bytes<32>, Map<Bytes<32>, Uint<128>>>;

/**
 * @witness secretKey
 * @description A private per-user nonce used in deriving the shielded user identifiers.
 * Combined with the user's public key to produce an obfuscated, unlinkable identity commitment.
 */
witness secretKey(): Bytes<32>;

/**
 * @witness encrypt
 * @description Encryption function used to encrypt the delivery address to
 * the selected carrier's encryption key.
 */
witness encrypt(data: Opaque<'string'>, encryptionPk: Opaque<'string'>): Opaque<'string'>;

// Construction circuit, where coin domain separator and color are defined.
// An initial nonce is provided which is then to generate new nonces for coin minting.
constructor(initNonce: Bytes<32>) {
  initialise(initNonce);
}

// Creates a new public offer for a given item.
// OfferState: () => New
export circuit offerItem(
                 itemId: Bytes<32>,
                 price: Uint<128>,
                 itemMeta: Opaque<'string'>,
                 sellerMeta: Opaque<'string'>
                 ): Offer {
  const sellerId = Utils_genSellerId(ownPublicKey(), secretKey(), kernel.self().bytes);
  const offerId = Utils_genOfferId(sellerId, itemId, price);
  const dOfferId = disclose(offerId);
  assert(!offers.member(dOfferId), "Offer already exists");

  if (!sellers.member(sellerId)) {
    // TODO: require the seller to be already registered
    sellers.insert(
      sellerId, Seller { id: sellerId, wallet: ownPublicKey(), meta: disclose(sellerMeta) });
  }
  const offer = Offer { ...default<Offer>,
                        id: offerId,
                        price: price,
                        meta: itemMeta,
                        seller: sellerId,
                        state: OfferState.New };
  offers.insert(dOfferId, disclose(offer));
  return offer;
}

// Adds a new carrier fee bid to an already published offer.
// Buyers will then be able to select a carrier among the bidders when buying the item.
// OfferState: New => New
export circuit setCarrierBid(
                 offerId: Bytes<32>,
                 fee: Uint<128>,
                 encryptionPk: Opaque<'string'>,
                 carrierMeta: Opaque<'string'>
                 ): [] {
  const offer = checkOfferState(offerId, OfferState.New);

  const carrierId = Utils_genCarrierId(ownPublicKey(), secretKey(), kernel.self().bytes);
  if (!carriers.member(carrierId)) {
    // TODO: request the carrier to be already registered
    carriers.insert(
      carrierId,
      Carrier { id: carrierId,
                wallet: ownPublicKey(),
                encryptionPk: disclose(encryptionPk),
                meta: disclose(carrierMeta) });
  }

  if (!carrierBids.member(offer.id)) {
    carrierBids.insert(offer.id, default<Map<Bytes<32>, Uint<128>>>);
  }

  carrierBids.lookup(offer.id).insert(carrierId, disclose(fee));
}

// Update the estimated time of arrival (ETA) of an offer already in transit.
// OfferState: InTransit => InTransit
export circuit setOfferEta(offerId: Bytes<32>, timestamp: Uint<128>): [] {
  const offer = checkOfferState(offerId, OfferState.InTransit);
  assert(Utils_isCallerTheCarrier(offer, secretKey()), "Only the carrier selected for an offer can set its delivery ETA");

  const updatedOffer = Offer { ...offer, deliveryEta: disclose(timestamp) };
  offers.insert(offer.id, updatedOffer);
}

// Purchase the item of a published offer, prodiving the ID of the carrier
// selected among the current fee bidders. Only the selected carrier can
// then pick up the item for delivery.
// OfferState: New => Purchased
export circuit purchaseItem(
                 offerId: Bytes<32>,
                 carrierId: Bytes<32>,
                 coinInfo: CoinInfo,
                 deliveryAddress: Opaque<'string'>
                 ): [] {
  const offer = checkOfferState(offerId, OfferState.New);

  assert(carrierBids.member(offer.id), "No carriers found for the offer");
  const dCarrierId = disclose(carrierId);
  assert(carrierBids.lookup(offer.id).member(dCarrierId), "Carrier not found among bidders");
  assert(carriers.member(dCarrierId), "Carrier is not registered");
  const encryptionPk = carriers.lookup(dCarrierId).encryptionPk;
  const fee = carrierBids.lookup(offer.id).lookup(dCarrierId);
  assert(coinInfo.value == offer.price + fee, "Deposit amount must be equal to the item price plus the carrier fee");

  // deposit according to price and carrier fee
  receiveDeposit(coinInfo);

  const buyerId = Utils_genBuyerId(ownPublicKey(), secretKey(), kernel.self().bytes);
  const purchaseDetails =
                some<PurchaseDetails>(
                  PurchaseDetails { buyerId: buyerId,
                                    refundWallet: ownPublicKey(),
                                    selectedCarrierId: dCarrierId,
                                    carrierFee: fee,
                                    deliveryAddress: disclose(encrypt(deliveryAddress, encryptionPk)) });
  const updatedOffer =
                Offer { ...offer, purchaseDetails: purchaseDetails, state: OfferState.Purchased };
  offers.insert(offer.id, updatedOffer);
  carrierBids.remove(offer.id);
}

// Item is being picked up by the selected carrier, changing the offer state,
// and locking the deposit made by the carrier according to the item's price.
// OfferState: Purchased => PickedUp
export circuit itemPickedUp(offerId: Bytes<32>, coinInfo: CoinInfo, eta: Maybe<Uint<128>>): [] {
  const offer = checkOfferState(offerId, OfferState.Purchased);
  assert(Utils_isCallerTheCarrier(offer, secretKey()), "Only the selected carrier can pick this item up for delivery");

  // deposit should be equal to the amount deposited by the buyer, i.e. item's price + delviery fee
  const fee = offer.purchaseDetails.value.carrierFee;
  assert(coinInfo.value == offer.price + fee, "Deposit amount must be equal to the item price plus the carrier fee");
  receiveDeposit(coinInfo);

  if (disclose(eta.is_some)) {
     setOfferState(Offer { ...offer, deliveryEta: disclose(eta.value) }, OfferState.PickedUp);
  } else {
     setOfferState(offer, OfferState.PickedUp);
  }
}

// The seller confirms the carrier has picked the item up for delivery.
// The seller may request the carrier to proove it's the selected carrier for the offer beforehand.
// OfferState: PickedUp => InTransit
export circuit confirmItemInTransit(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.PickedUp);
  assert(Utils_isCallerTheSeller(offer, secretKey()), "Only the seller can confirm the item has been picked up for delivery");

  setOfferState(offer, OfferState.InTransit);
}

// The carrier declares it has delivered the item to the buyer.
// The carrier may request the buyer to proove it's the buyer of the offer beforehand.
// OfferState: InTransit => Delivered
export circuit delivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.InTransit);
  assert(Utils_isCallerTheCarrier(offer, secretKey()), "Only the carrier can set the item as delivered");

  setOfferState(offer, OfferState.Delivered);
}

// The buyer confirms it received the purchased item and no dispute needs to be opened.
// OfferState: Delivered => Completed
export circuit confirmDelivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Delivered);
  assert(Utils_isCallerTheBuyer(offer, secretKey()), "Only the buyer can confirm the item has been delivered");

  // release deposits to carrier, plus the owned carrier fee
  const fee = offer.purchaseDetails.value.carrierFee;
  const amount = offer.price + fee + fee;
  const carrier = carriers.lookup(offer.purchaseDetails.value.selectedCarrierId);
  sendPayment(carrier.wallet, amount as Uint<128>);

  // release deposits to seller
  const seller = sellers.lookup(offer.seller);
  sendPayment(seller.wallet, offer.price);

  setOfferState(offer, OfferState.Completed);
}

// The buyer opens a dispute on the item it received.
// OfferState: Delivered => Dispute
// TODO: allow to dispute when it was not delivered but intransit
export circuit disputeItem(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Delivered);
  assert(Utils_isCallerTheBuyer(offer, secretKey()), "Only the buyer can open a dispute on the item");

  setOfferState(offer, OfferState.Dispute);
}

// The seller resolves a dispute.
// Currently this only supports a resolution where the carrier is punished and the buyer refunded.
// OfferState: Dispute => Completed
export circuit resolveDispute(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Dispute);
  assert(Utils_isCallerTheSeller(offer, secretKey()), "Only the seller can resolve a dispute");

  // TODO: relese deposits and apply confiscations according to different resolution types.
  // Currently, just as a demonstration of one type of resolution action to be taken by this circuit,
  // we refund the buyer plus the delivery fee deposited by the carrier as a compensation,
  // and burn the rest of the funds that were deposited by the carrier, which is equal to item's price.
  const refundAmount = offer.price + 2 * offer.purchaseDetails.value.carrierFee as Uint<128>;
  sendPayment(offer.purchaseDetails.value.refundWallet, refundAmount);
  _sendPayment(burnAddress(), offer.price);

  setOfferState(offer, OfferState.Completed);
}

// The carrier or buyer of the offer can rate the seller, and only once.
// OfferState: Completed => Completed
export circuit rateSeller(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0 and smaller than 256");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isBuyer = Utils_isCallerTheBuyer(offer, secretKey());
  const isCarrier = Utils_isCallerTheCarrier(offer, secretKey());
  assert(isCarrier || isBuyer, "Only the carrier or buyer of the offer can rate the seller");

  if (isCarrier) {
    assert(offer.sellerRatings[0] == 0, "The rate for the seller was already set by the carrier");
    const updatedOffer =
                  Offer { ...offer, sellerRatings: [disclose(rating), offer.sellerRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isBuyer) {
    assert(offer.sellerRatings[1] == 0, "The rate for the seller was already set by the buyer");
    const updatedOffer =
                  Offer { ...offer, sellerRatings: [offer.sellerRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

// The buyer or seller of the offer can rate the carrier, and only once.
// OfferState: Completed => Completed
export circuit rateCarrier(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0 and smaller than 256");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isBuyer = Utils_isCallerTheBuyer(offer, secretKey());
  const isSeller = Utils_isCallerTheSeller(offer, secretKey());
  assert(isSeller || isBuyer, "Only the seller or buyer of the offer can rate the carrier");

  if (isSeller) {
    assert(offer.carrierRatings[0] == 0, "The rate for the carrier was already set by the seller");
    const updatedOffer =
                  Offer { ...offer, carrierRatings: [disclose(rating), offer.carrierRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isBuyer) {
    assert(offer.carrierRatings[1] == 0, "The rate for the carrier was already set by the buyer");
    const updatedOffer =
                  Offer { ...offer, carrierRatings: [offer.carrierRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

// The carrier or seller of the offer can rate the buyer, and only once.
// OfferState: Completed => Completed
export circuit rateBuyer(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0 and smaller than 256");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isCarrier = Utils_isCallerTheCarrier(offer, secretKey());
  const isSeller = Utils_isCallerTheSeller(offer, secretKey());
  assert(isSeller || isCarrier, "Only the seller or carrier of the offer can rate the buyer");

  if (isSeller) {
    assert(offer.buyerRatings[0] == 0, "The rate for the buyer was already set by the seller");
    const updatedOffer = Offer { ...offer, buyerRatings: [disclose(rating), offer.buyerRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isCarrier) {
    assert(offer.buyerRatings[1] == 0, "The rate for the buyer was already set by the carrier");
    const updatedOffer = Offer { ...offer, buyerRatings: [offer.buyerRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

// Check offer state and return it
export circuit checkOfferState(offerId: Bytes<32>, expectedState: OfferState): Offer {
  const dOfferId = disclose(offerId);
  assert(offers.member(dOfferId), "Offer not found");
  const offer = offers.lookup(dOfferId);
  if (expectedState == OfferState.New) {
    assert(offer.state == expectedState, "Item has already been purchased");
  }
  if (expectedState == OfferState.Purchased) {
    assert(offer.state == expectedState, "Item has not been purchased or already picked up");
  }
  if (expectedState == OfferState.PickedUp) {
    assert(offer.state == expectedState, "Item has not been purchased or already confirmed as picked up");
  }
  if (expectedState == OfferState.InTransit) {
    assert(offer.state == expectedState, "Item has been already delivered or it was not yet picked up for delivery");
  }
  if (expectedState == OfferState.Delivered) {
    assert(offer.state == expectedState, "The item was already confirmed as delivered, or it has not been delivered yet");
  }
  if (expectedState == OfferState.Dispute) {
    assert(offer.state == expectedState, "The item is not marked as being in dispute");
  }
  if (expectedState == OfferState.Completed) {
    assert(offer.state == expectedState, "The offer has not been marked as completed yet");
  }

  return offer;
}

// Set Offer state
circuit setOfferState(offer: Offer, newState: OfferState): [] {
  const updatedOffer = Offer { ...offer, state: newState };
  offers.insert(offer.id, updatedOffer);
}
