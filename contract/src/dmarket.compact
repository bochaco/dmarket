pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

/**** Notes:
- Contract Address Support: Seller, buyer, and carrier roles do not currently support contract addresses.
- Transaction History Storage: While transaction history is being stored, future versions may implement external storage solutions.
- Star Rating System: Ratings are calculated based on stars awarded in each completed offer.
Each star corresponds to 50 rating points. For example, 150 rating points equals 3 stars.
    Rating Scale:
        [1, 50): 1 star
        [50, 100): 2 stars
        [100, 150): 3 stars
        [150, 200): 4 stars
        â‰¥ 200: 5 stars
- Dispute Initiation: Only buyers have the ability to open disputes at present, but future updates will allow carriers to do the same.
- Dispute Resolution: The seller currently acts as the arbitrator for disputes initiated by the buyer. In future versions, an option for selecting an external arbitrator service will be available.

TODO:
- Anonymization: Implement anonymization for sellers, buyers, and carriers using OpenZeppelin tools.
- Testing: Develop tests for circuit functionality.
- Deposits Management: Introduce a system for managing deposits.
****/

// Information kept for registered carriers
export struct Carrier {
  // Unique ID of the carrier
  id: Bytes<32>,
  // Wallet of the carrier where fees payment shall be sent.
  wallet: ZswapCoinPublicKey,
  // Number of completed transactions.
  txCompleted: Uint<128>,
  // Optional metadata, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>
}

// Information kept for registered sellers
export struct Seller {
  // Unique ID of the carrier
  id: Bytes<32>,
  // Wallet of the seller where payments shall be sent.
  wallet: ZswapCoinPublicKey,
  // Number of completed transactions.
  txCompleted: Uint<128>,
  // Optional metadata, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>
}

// Maps carriers and sellers IDs to their registered information.
// Updated only when a offer gets completed.
export ledger carriers: Map<Bytes<32>, Carrier>;

export ledger sellers: Map<Bytes<32>, Seller>;

// A list of active escrows. Maps the offer IDs
// to the deposits made in relation to it.
export ledger escrowDeposits: Map<Bytes<32>, [Uint<128>, Uint<128>]>;

// Type to track the state of each published offer
export enum OfferState {
  // New offer created and published.
  New,
  // A buyer selected the offer and made the deposit.
  Purchased,
  // The carrier accepted and made the deposit.
  PickedUp,
  // The seller confirmed the item was picked up by the carrier for deivery. The seller
  // may request a signature to the carrier, generated by the dApp with
  // the carrier ID, to verify he/she is the effectivelly the carrier selected by the buyer.
  InTransit,
  // The carrier declares to have delivered the good/item. The carrier may request
  // a signature to the buyer, generated by the dApp with buyer ID, to confirm he/she is effectively the buyer.
  Delivered,
  // The buyer has opened a dispute which will need to be solved by the seller.
  Dispute,
  // Either the buyer confirmed the good/item was delivered and happy with it, or
  // a dispute was opened and already resolved by the seller.
  Completed
}

// Published item
export struct Item {
  // Id of the item.
  id: Bytes<32>,
  // Price of the offered item.
  price: Uint<128>,
  // Optional metadata for the item, format and content to be interpreted by the dApp.
  meta: Opaque<'string'>
}

// Maps the offer IDs to the carriers offered to deliver the item and their bidding fee price.
export ledger carrierBids: Map<Bytes<32>, Map<Bytes<32>, Uint<128>>>;

// Information defined when an offer is purchased, including selected carrier and agreed fee
export struct PurchaseDetails {
  buyerId: Bytes<32>,
  selectedCarrierId: Bytes<32>,
  carrierFee: Uint<128>
}

// Published offer
export struct Offer {
  // ID of the offer
  id: Bytes<32>,
  // The item/good being offered
  item: Item,
  // Current state of the offer
  state: OfferState,
  // ID of the seller.
  seller: Bytes<32>,
  // A tuple containing the buyer ID, the selected carrier ID, and the fee price.
  purchaseDetails: Maybe<PurchaseDetails>,
  // Estimated time of arrival (timestamp) of the item
  // Only the chosen carrier can set/update this value.
  deliveryEta: Uint<128>,
  // Rating given to the seller, by the carrier and buyer respectively.
  sellerRatings: [Uint<8>, Uint<8>],
  // Rating given to the carrier, by the seller and buyer respectively.
  carrierRatings: [Uint<8>, Uint<8>],
  // Rating given to the buyer, by the seller and carrier respectively.
  buyerRatings: [Uint<8>, Uint<8>],
}

// Maps offers IDs to their info including state.
export ledger offers: Map<Bytes<32>, Offer>;

constructor() {
}

// Creates a new public offer for a given item.
// OfferState: () => New
export circuit offerItem(item: Item): Offer {
  const sellerId = genSellerId(ownPublicKey());
  const offerId = genOfferId(item, sellerId);
  const disclosedOfferId = disclose(offerId);
  assert(!offers.member(disclosedOfferId), "Offer already exists");

  if (!sellers.member(sellerId)) {
    // TODO: get seller info from a param of this circuit
    sellers.insert(sellerId, default<Seller>);
  }
  const offer = Offer { ...default<Offer>,
                        id: offerId,
                        item: item,
                        seller: sellerId,
                        state: OfferState.New };
  offers.insert(disclosedOfferId, disclose(offer));
  return offer;
}

// Adds a new carrier fee bid to an already published offer.
// Buyers will then be able to select a carrier among the bidders when buying the item.
// OfferState: New => New
export circuit setCarrierBid(offerId: Bytes<32>, fee: Uint<128>): [] {
  const offer = checkOfferState(offerId, OfferState.New);

  const carrierId = genCarrierId(ownPublicKey());
  if (!carriers.member(carrierId)) {
    // TODO: get carrier info from a param of this circuit
    carriers.insert(carrierId, default<Carrier>);
  }

  if (!carrierBids.member(offer.id)) {
    carrierBids.insert(offer.id, default<Map<Bytes<32>, Uint<128>>>);
  }

  carrierBids.lookup(offer.id).insert(carrierId, disclose(fee));
}

// Update the estimated time of arrival (ETA) of an offer already in transit.
// OfferState: InTransit => InTransit
export circuit setOfferEta(offerId: Bytes<32>, timestamp: Uint<128>): [] {
  const offer = checkOfferState(offerId, OfferState.InTransit);
  assert(isCallerTheCarrier(offer), "Only the carrier selected for an offer can set its delivery ETA");

  const updatedOffer = Offer { ...offer, deliveryEta: disclose(timestamp) };
  offers.insert(offer.id, updatedOffer);
}

// Purchase the item of a published offer, prodiving the ID of the carrier
// selected among the current fee bidders. Only the selected carrier can
// then pick up the item for delivery.
// OfferState: New => Purchased
export circuit purchaseItem(offerId: Bytes<32>, carrierId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.New);

  assert(carrierBids.member(offer.id), "No carriers found for the offer");
  const disclosedCarrierId = disclose(carrierId);
  assert(carrierBids.lookup(offer.id).member(disclosedCarrierId), "Carrier not found among bidders");
  const fee = carrierBids.lookup(offer.id).lookup(disclosedCarrierId);

  // TODO: handle deposit according to price and carrier fee

  const buyerId = genBuyerId(ownPublicKey());
  const purchaseDetails =
                some<PurchaseDetails>(
                  PurchaseDetails { buyerId: buyerId,
                                    selectedCarrierId: disclosedCarrierId,
                                    carrierFee: fee });
  const updatedOffer =
                Offer { ...offer, purchaseDetails: purchaseDetails, state: OfferState.Purchased };
  offers.insert(offer.id, updatedOffer);
}

// Item is being picked up by the selected carrier, changing the offer state,
// and locking the deposit made by the carrier according to the item's price.
// OfferState: Purchased => PickedUp
export circuit itemPickedUp(offerId: Bytes<32>, eta: Maybe<Uint<128>>): [] {
  const offer = checkOfferState(offerId, OfferState.Purchased);
  assert(isCallerTheCarrier(offer), "Only the selected carrier can pick this item up for delivery");

  // TODO: handle deposit according to price

  if (disclose(eta.is_some)) {
     setOfferState(Offer { ...offer, deliveryEta: disclose(eta.value) }, OfferState.PickedUp);
  } else {
     setOfferState(offer, OfferState.PickedUp);
  }
}

// The seller confirms the carrier has picked the item up for delivery.
// The seller may request the carrier to proove it's the selected carrier for the offer beforehand.
// OfferState: PickedUp => InTransit
export circuit confirmItemInTransit(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.PickedUp);
  assert(isCallerTheSeller(offer), "Only the seller can confirm the item has been picked up for delivery");

  setOfferState(offer, OfferState.InTransit);
}

// The carrier declares it has delivered the item to the buyer.
// The carrier may request the buyer to proove it's the buyer of the offer beforehand.
// OfferState: InTransit => Delivered
export circuit delivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.InTransit);
  assert(isCallerTheCarrier(offer), "Only the carrier can set the item as delivered");

  setOfferState(offer, OfferState.Delivered);
}

// The buyer confirms it received the purchased item and no dispute needs to be opened.
// OfferState: Delivered => Completed
export circuit confirmDelivered(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Delivered);
  assert(isCallerTheBuyer(offer), "Only the buyer can confirm the item has been delivered");

  // TODO: release deposits to each party

  setOfferState(offer, OfferState.Completed);
}

// The buyer opens a dispute on the item it received.
// OfferState: Delivered => Dispute
// TODO: allow to dispute when it was not delivered but intransit
export circuit disputeItem(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Delivered);
  assert(isCallerTheBuyer(offer), "Only the buyer can open a dispute on the item");

  setOfferState(offer, OfferState.Dispute);
}

// The seller resolves a dispute.
// OfferState: Dispute => Completed
export circuit resolveDispute(offerId: Bytes<32>): [] {
  const offer = checkOfferState(offerId, OfferState.Dispute);
  assert(isCallerTheSeller(offer), "Only the seller can resolve a dispute");

  // TODO: relese deposits and apply confiscations accordingly

  setOfferState(offer, OfferState.Completed);
}

// The carrier or buyer of the offer can rate the seller, and only once.
// OfferState: Completed => Completed
export circuit rateSeller(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isBuyer = isCallerTheBuyer(offer);
  const isCarrier = isCallerTheCarrier(offer);
  assert(isCarrier || isBuyer, "Only the carrier or buyer of the offer can rate the seller");

  if (isCarrier) {
    assert(offer.sellerRatings[0] == 0, "The rate for the seller was already set by the carrier");
    const updatedOffer =
                  Offer { ...offer, sellerRatings: [disclose(rating), offer.sellerRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isBuyer) {
    assert(offer.sellerRatings[1] == 0, "The rate for the seller was already set by the buyer");
    const updatedOffer =
                  Offer { ...offer, sellerRatings: [offer.sellerRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

// The buyer or seller of the offer can rate the carrier, and only once.
// OfferState: Completed => Completed
export circuit rateCarrier(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isBuyer = isCallerTheBuyer(offer);
  const isSeller = isCallerTheSeller(offer);
  assert(isSeller || isBuyer, "Only the seller or buyer of the offer can rate the carrier");

  if (isSeller) {
    assert(offer.carrierRatings[0] == 0, "The rate for the carrier was already set by the seller");
    const updatedOffer =
                  Offer { ...offer, carrierRatings: [disclose(rating), offer.carrierRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isBuyer) {
    assert(offer.carrierRatings[1] == 0, "The rate for the carrier was already set by the buyer");
    const updatedOffer =
                  Offer { ...offer, carrierRatings: [offer.carrierRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

// The carrier or seller of the offer can rate the buyer, and only once.
// OfferState: Completed => Completed
export circuit rateBuyer(offerId: Bytes<32>, rating: Uint<8>): [] {
  assert(rating > 0, "Rate needs to be greater than 0");
  const offer = checkOfferState(offerId, OfferState.Completed);
  const isCarrier = isCallerTheCarrier(offer);
  const isSeller = isCallerTheSeller(offer);
  assert(isSeller || isCarrier, "Only the seller or carrier of the offer can rate the buyer");

  if (isSeller) {
    assert(offer.buyerRatings[0] == 0, "The rate for the buyer was already set by the seller");
    const updatedOffer = Offer { ...offer, buyerRatings: [disclose(rating), offer.buyerRatings[1]] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
  if (isCarrier) {
    assert(offer.buyerRatings[1] == 0, "The rate for the buyer was already set by the carrier");
    const updatedOffer = Offer { ...offer, buyerRatings: [offer.buyerRatings[0], disclose(rating)] };
    offers.insert(disclose(offer.id), updatedOffer);
  }
}

// Check the caller is the buyer
circuit isCallerTheBuyer(offer: Offer): Boolean {
  const buyerId = genBuyerId(ownPublicKey());
  return (offer.purchaseDetails.is_some && offer.purchaseDetails.value.buyerId == buyerId);
}

// Check the caller is the selected carrier
circuit isCallerTheCarrier(offer: Offer): Boolean {
  const carrierId = genCarrierId(ownPublicKey());
  return (offer.purchaseDetails.is_some &&
          offer.purchaseDetails.value.selectedCarrierId == carrierId);
}

// Check the caller is the seller
circuit isCallerTheSeller(offer: Offer): Boolean {
  const sellerId = genSellerId(ownPublicKey());
  return (offer.seller == sellerId);
}

// Generates an Offer ID using the Item's fields and seller ID
export circuit genOfferId(item: Item, sellerId: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<4, Bytes<32>>>(
           [pad(32, "dmarket_offer_id:"), item.id, sellerId, item.price as Bytes<32>]);
}

// Check offer state and return it
circuit checkOfferState(offerId: Bytes<32>, expectedState: OfferState): Offer {
  const disclosedOfferId = disclose(offerId);
  assert(offers.member(disclosedOfferId), "Offer not found");
  const offer = offers.lookup(disclosedOfferId);
  if (expectedState == OfferState.New) {
    assert(offer.state == expectedState, "Item has already been purchased");
  }
  if (expectedState == OfferState.Purchased) {
    assert(offer.state == expectedState, "Item has not been purchased or already picked up");
  }
  if (expectedState == OfferState.PickedUp) {
    assert(offer.state == expectedState, "Item has not been purchased or already confirmed as picked up");
  }
  if (expectedState == OfferState.InTransit) {
    assert(offer.state == expectedState, "Item has been already delivered or it was not yet picked up for delivery");
  }
  if (expectedState == OfferState.Delivered) {
    assert(offer.state == expectedState, "The item was already confirmed as delivered, or it has not been delivered yet");
  }
  if (expectedState == OfferState.Dispute) {
    assert(offer.state == expectedState, "The item is not marked as being in dispute");
  }
  if (expectedState == OfferState.Completed) {
    assert(offer.state == expectedState, "The offer has not been marked as completed yet");
  }

  return offer;
}

// Set Offer state
circuit setOfferState(offer: Offer, newState: OfferState): [] {
  const updatedOffer = Offer { ...offer, state: newState };
  offers.insert(offer.id, updatedOffer);
}

// TODO: use OpenZeppelin tools.
// Generates a seller ID from a public key.
export circuit genSellerId(pk: ZswapCoinPublicKey): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "dmarket_seller_id:"), pk.bytes]));
}

// TODO: use OpenZeppelin tools.
// Generates a buyer ID from a public key.
export circuit genBuyerId(pk: ZswapCoinPublicKey): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "dmarket_buyer_id:"), pk.bytes]));
}

// TODO: use OpenZeppelin tools.
// Generates a carrier ID from a public key.
export circuit genCarrierId(pk: ZswapCoinPublicKey): Bytes<32> {
  return disclose(persistentHash<Vector<2, Bytes<32>>>([pad(32, "dmarket_carrier_id:"), pk.bytes]));
}
