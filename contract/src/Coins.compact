module Coins {
  import CompactStandardLibrary;

  // Escrow ledger holding shielded coin deposits for active offers.
  // Uses `QualifiedShieldedCoinInfo` to represent the on-ledger aggregated coin.
  export ledger treasury: QualifiedShieldedCoinInfo;

  // Domain separator used to mint the shielded tokens
  export ledger coinDomainSeparator: Bytes<32>;

  // Total number of ever minted shielded coins by this contract
  export ledger totalMinted: Uint<64>;

  // Counter and nonce are used to derive a unique nonce when minting new shielded coins
  ledger mintCounter: Counter;

  ledger mintNonce: Bytes<32>;

  // Flag to track whether `treasury` currently holds any coins.
  ledger treasuryWithCoins: Boolean;

  export circuit initialise(initNonce: Bytes<32>): [] {
    mintNonce = disclose(initNonce);
    coinDomainSeparator = pad(32, "dmarket_shielded_coin");
  }

  // Mint shielded coins to be owned by the caller.
  // NOTE: this is sample/demo minting logic that grants `10000` tokens per call.
  // Real deployments should implement stricter minting controls.
  export circuit mintCoins(): [] {
    // Demo: mint a fixed amount to the caller each invocation.
    mintCounter.increment(1);
    const newNonce = evolveNonce(mintCounter, mintNonce);
    const amount: Uint<64> = 10000;

    totalMinted = totalMinted + amount as Uint<64>;
    mintShieldedToken(
      coinDomainSeparator,
      amount,
      newNonce,
      left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));

    mintNonce = newNonce;
  }

  // Receive a shielded deposit and store it in this contract's `treasury` (escrow).
  export circuit receiveDeposit(coinInfo: ShieldedCoinInfo): [] {
    // Accept only shielded coins minted for this dMarket contract (color check).
    const myCoinColor = tokenType(coinDomainSeparator, disclose(kernel.self()));
    assert(coinInfo.color == myCoinColor, "Only dMarket coins can be used for payments");

    receiveShielded(disclose(coinInfo));
    const me = right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
    if (!treasuryWithCoins) {
       treasury.writeCoin(disclose(coinInfo), me);
       treasuryWithCoins = true;
    } else {
       const mergedCoin = mergeCoinImmediate(treasury, disclose(coinInfo));
       treasury.writeCoin(disclose(mergedCoin), me);
    }
  }

  // Send two payments in sequence using the treasury as source.
  // - First sends `amount` to `to`.
  // - Then sends `thenAmount` to `thenTo` using the change from the first send.
  // If any change remains after the second send it is stored back in `treasury`.
  export circuit sendPayments(
                   to: Either<ZswapCoinPublicKey, ContractAddress>,
                   amount: Uint<128>,
                   thenTo: Either<ZswapCoinPublicKey, ContractAddress>,
                   thenAmount: Uint<128>
                   ): [] {
    const sendResult = sendShielded(treasury, to, disclose(amount));
    assert(sendResult.sent.value == amount, "Failed to send payment");
    assert(sendResult.change.is_some, "Treasury is unexpectedly out of funds");

    const secondSendResult = sendImmediateShielded(sendResult.change.value, thenTo, disclose(thenAmount));
    assert(secondSendResult.sent.value == thenAmount, "Failed to send immediate payment");
    if (secondSendResult.change.is_some) {
       const me = right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
       treasury.writeCoin(secondSendResult.change.value, me);
    } else {
       treasuryWithCoins = false;
       treasury.resetToDefault();
    }
  }
}
