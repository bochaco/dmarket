module Utils {
  import CompactStandardLibrary;
  import "./Types";

  // Check the caller is the buyer
  export circuit isCallerTheBuyer(offer: Offer, secret: Bytes<32>): Boolean {
    const buyerId = genBuyerId(ownPublicKey(), secret, kernel.self().bytes);
    return (offer.purchaseDetails.is_some && offer.purchaseDetails.value.buyerId == buyerId);
  }

  // Check the caller is the selected carrier
  export circuit isCallerTheCarrier(offer: Offer, secret: Bytes<32>): Boolean {
    const carrierId = genCarrierId(ownPublicKey(), secret, kernel.self().bytes);
    return (offer.purchaseDetails.is_some &&
            offer.purchaseDetails.value.selectedCarrierId == carrierId);
  }

  // Check the caller is the seller
  export circuit isCallerTheSeller(offer: Offer, secret: Bytes<32>): Boolean {
    const sellerId = genSellerId(ownPublicKey(), secret, kernel.self().bytes);
    return (offer.seller == sellerId);
  }

  // Generates an Offer ID using the item's id, price, and seller ID
  export circuit genOfferId(sellerId: Bytes<32>, itemId: Bytes<32>, price: Uint<128>): Bytes<32> {
    return persistentHash<Vector<4, Bytes<32>>>(
             [pad(32, "dmarket_offer_id:"), sellerId, itemId, price as Bytes<32>]);
  }

  // Generates a seller ID from a public key.
  export circuit genSellerId(pk: ZswapCoinPublicKey, nonce: Bytes<32>, instanceSalt: Bytes<32>): Bytes<32> {
    return (computeUserId(pk, nonce, instanceSalt, pad(32, "dmarket_seller_id:")));
  }

  // Generates a buyer ID from a public key.
  export circuit genBuyerId(pk: ZswapCoinPublicKey, nonce: Bytes<32>, instanceSalt: Bytes<32>): Bytes<32> {
    return (computeUserId(pk, nonce, instanceSalt, pad(32, "dmarket_buyer_id:")));
  }

  // Generates a carrier ID from a public key.
  export circuit genCarrierId(pk: ZswapCoinPublicKey, nonce: Bytes<32>, instanceSalt: Bytes<32>): Bytes<32> {
    return (computeUserId(pk, nonce, instanceSalt, pad(32, "dmarket_carrier_id:")));
  }

  /*
   * Create a shielded user ID.
   *
   * Purpose:
   * - Produces a deterministic, obfuscated identifier derived from the user's public key,
   *   a private `nonce` (witness) and an `instanceSalt` to scope IDs to this contract instance.
   * - The `domain` parameter differentiates IDs for sellers/buyers/carriers so they do not collide.
   *
   * Parameters:
   * - `pk`: user's public key for the identity being committed.
   * - `nonce`: per-user secret provided as a witness to avoid linkability.
   * - `instanceSalt`: contract instance-specific salt (e.g. `kernel.self().bytes`) to avoid cross-contract collisions.
   * - `domain`: a 32-byte domain/prefix (e.g. `pad(32, "dmarket_seller_id:")`) to further separate ID namespaces.
   *
   * Returns: computed user ID (Bytes<32>), disclosed to allow ledger usage as a map key.
   */
  export circuit computeUserId(
                   pk: ZswapCoinPublicKey,
                   nonce: Bytes<32>,
                   instanceSalt: Bytes<32>,
                   domain: Bytes<32>
                   ): Bytes<32> {
    // Use the provided `domain` to produce distinct IDs per role (seller/buyer/carrier).
    return disclose(persistentHash<Vector<4, Bytes<32>>>(
                      [pk.bytes, nonce, instanceSalt, domain]));
  }
}
